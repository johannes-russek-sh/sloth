package chronosphere

import (
	"context"
	"fmt"
	"io"

	"strings"

	"github.com/slok/sloth/internal/prometheus"
	"gopkg.in/yaml.v2"

	"github.com/slok/sloth/internal/info"
	"github.com/slok/sloth/internal/log"
)

var (
	// ErrNoSLORules will be used when there are no rules to store. The upper layer
	// could ignore or handle the error in cases where there wasn't an output.
	ErrNoSLORules = fmt.Errorf("0 SLO Prometheus rules generated")
)

func NewIOWriterGroupedRulesYAMLRepo(writer io.Writer, logger log.Logger) IOWriterGroupedRulesYAMLRepo {
	return IOWriterGroupedRulesYAMLRepo{
		writer: writer,
		logger: logger.WithValues(log.Kv{"svc": "storage.IOWriter", "format": "yaml"}),
	}
}

// IOWriterGroupedRulesYAMLRepo knows to store all the SLO rules (recordings and alerts)
// grouped in an IOWriter in YAML format, that is compatible with Prometheus.
type IOWriterGroupedRulesYAMLRepo struct {
	writer io.Writer
	logger log.Logger
}

type StorageSLO struct {
	SLO   prometheus.SLO
	Rules prometheus.SLORules
}

// StoreSLOs will store the recording and alert prometheus rules, if grouped is false it will
// split and store as 2 different groups the alerts and the recordings, if true
// it will be save as a single group.
func (i IOWriterGroupedRulesYAMLRepo) StoreSLOs(ctx context.Context, slos []StorageSLO) error {
	if len(slos) == 0 {
		return fmt.Errorf("slo rules required")
	}

	// If we don't have anything to store, error so we can increase the reliability
	// because maybe this was due to an unintended error (typos, misconfig, too many disable...).
	rules := 0
	err := error(nil)
	var rulesYaml []byte

	logger := i.logger.WithCtxValues(ctx)

	// Convert to YAML (Prometheus rule format).
	rules, rulesYaml, err = rawChronosphereYAML(slos, logger)

	if err != nil {
		return err
	}

	rulesYaml = writeTopDisclaimer(rulesYaml)
	_, err = i.writer.Write(rulesYaml)
	if err != nil {
		return fmt.Errorf("could not write top disclaimer: %w", err)
	}

	logger.WithValues(log.Kv{"groups": rules}).Infof("Prometheus rules written")

	return nil
}
func rawChronosphereYAML(slos []StorageSLO, logger log.Logger) (int, []byte, error) {
	collections := make(map[string]chronosphereCollection)
	rules := []chronosphereRecordingRule{}
	monitors := []chronosphereMonitor{}

	for _, slo := range slos {
		collection := createChronosphereCollection(slo)
		rules = append(rules, createChronosphereRecordingRules(slo, collection.Slug)...)
		monitors = append(monitors, createChronosphereMonitors(slo, collection.Slug, logger)...)
		collections[collection.Slug] = collection
	}

	if len(collections) == 0 {
		return 0, nil, ErrNoSLORules
	}

	outputYaml := make([]byte, 0)

	for _, collection := range collections {
		chronosphereCollectionYAML := NewChronosphereCollectionYAML()
		chronosphereCollectionYAML.Spec = collection
		collectionYaml, err := yaml.Marshal(chronosphereCollectionYAML)
		if err != nil {
			return 0, nil, fmt.Errorf("could not format collections: %w", err)
		}
		outputYaml = append(outputYaml, collectionYaml...)
		outputYaml = append(outputYaml, []byte("---\n")...)
	}

	for _, rule := range rules {
		chronosphereRuleYAML := NewChronosphereRecordingRuleYAML()
		chronosphereRuleYAML.Spec = rule
		ruleYaml, err := yaml.Marshal(chronosphereRuleYAML)
		if err != nil {
			return 0, nil, fmt.Errorf("could not format recording rule: %w", err)
		}
		outputYaml = append(outputYaml, ruleYaml...)
		outputYaml = append(outputYaml, []byte("---\n")...)
	}

	for _, monitor := range monitors {
		chronosphereMonitorYAML := NewChronosphereMonitorYAML()
		chronosphereMonitorYAML.Spec = monitor
		monitorYaml, err := yaml.Marshal(chronosphereMonitorYAML)
		if err != nil {
			return 0, nil, fmt.Errorf("could not format monitor: %w", err)
		}
		outputYaml = append(outputYaml, monitorYaml...)
		outputYaml = append(outputYaml, []byte("---\n")...)
	}

	return len(collections), outputYaml, nil
}

func createChronosphereCollection(slo StorageSLO) chronosphereCollection {
	return chronosphereCollection{
		Slug:        fmt.Sprintf("sloth-slo-%s", slo.SLO.Service),
		Name:        fmt.Sprintf("sloth-slo-%s", slo.SLO.Service),
		Description: "SLOs generated by Sloth",
	}
}

func createChronosphereRecordingRules(slo StorageSLO, collectionSlug string) []chronosphereRecordingRule {
	rules := []chronosphereRecordingRule{}
	for _, rule := range slo.Rules.SLIErrorRecRules {
		ruleId := fmt.Sprintf("sloth-slo-sli-recordings-%s-%s", slo.SLO.ID, strings.Replace(rule.Record, ":", "_", -1))
		chronoRule := chronosphereRecordingRule{
			Slug:          ruleId,
			Name:          ruleId,
			Collection:    collectionSlug,
			Interval_secs: 60,
			Metric_name:   rule.Record,
			Expr:          rule.Expr,
			Label_policy: chronosphereLabelPolicy{
				Add: rule.Labels,
			},
		}
		rules = append(rules, chronoRule)
	}

	for _, rule := range slo.Rules.MetadataRecRules {
		ruleId := fmt.Sprintf("sloth-slo-sli-recordings-%s-%s", slo.SLO.ID, strings.Replace(rule.Record, ":", "_", -1))
		chronoRule := chronosphereRecordingRule{
			Slug:          ruleId,
			Name:          ruleId,
			Collection:    collectionSlug,
			Interval_secs: 60,
			Metric_name:   rule.Record,
			Expr:          rule.Expr,
			Label_policy: chronosphereLabelPolicy{
				Add: rule.Labels,
			},
		}
		rules = append(rules, chronoRule)
	}

	return rules
}

func createChronosphereMonitors(slo StorageSLO, collectionSlug string, logger log.Logger) []chronosphereMonitor {
	monitors := []chronosphereMonitor{}
	for _, rule := range slo.Rules.AlertRules {
		severity, ok := rule.Labels["severity"]
		if !ok {
			logger.Warningf("alert rule %q doesn't have a severity label, skipping", rule.Alert)
			continue
		}
		conditions := map[string]map[string][]chronosphereMonitorConditions{
			severity: {
				"conditions": {
					chronosphereMonitorConditions{
						Value:                0,
						Sustain_secs:         60,
						Resolve_sustain_secs: 60,
						Op:                   chronosphereOperation(EXISTS).String(),
					},
				},
			},
		}

		ruleId := fmt.Sprintf("sloth-slo-alerts-%s-%s", slo.SLO.ID, strings.Replace(rule.Alert, ":", "_", -1))

		monitor := chronosphereMonitor{
			Slug:                     ruleId,
			Name:                     ruleId,
			Query:                    rule.Expr,
			Collection:               collectionSlug,
			Interval_secs:            60,
			Labels:                   rule.Labels,
			Notification_policy_slug: rule.Labels["routing_key"], // TODO set routing
			Series_conditions:        map[string]map[string]map[string][]chronosphereMonitorConditions{"defaults": conditions},
		}

		monitors = append(monitors, monitor)
	}
	return monitors
}

var disclaimer = fmt.Sprintf(`
---
# Code generated by Sloth (%s): https://github.com/slok/sloth.
# DO NOT EDIT.

`, info.Version)

func writeTopDisclaimer(bs []byte) []byte {
	return append([]byte(disclaimer), bs...)
}

type chronosphereCollectionYAML struct {
	Api_version string                 `yaml:"api_version"`
	Kind        string                 `yaml:"kind"`
	Spec        chronosphereCollection `yaml:"spec"`
}

func NewChronosphereCollectionYAML() chronosphereCollectionYAML {
	return chronosphereCollectionYAML{
		Api_version: "v1/config",
		Kind:        "Collection",
	}
}

type chronosphereCollection struct {
	Slug                     string `yaml:"slug"`
	Name                     string `yaml:"name"`
	Description              string `yaml:"description"`
	Team_slug                string `yaml:"team_slug,omitempty"`
	Notification_policy_slug string `yaml:"notification_policy_slug,omitempty"`
}

type chronosphereLabelPolicy struct {
	Add map[string]string `yaml:"add"`
}

type chronosphereRecordingRuleYAML struct {
	Api_version string                    `yaml:"api_version"`
	Kind        string                    `yaml:"kind"`
	Spec        chronosphereRecordingRule `yaml:"spec"`
}

func NewChronosphereRecordingRuleYAML() chronosphereRecordingRuleYAML {
	return chronosphereRecordingRuleYAML{
		Api_version: "v1/config",
		Kind:        "RecordingRule",
	}
}

type ChronosphereMonitorYAML struct {
	Api_version string              `yaml:"api_version"`
	Kind        string              `yaml:"kind"`
	Spec        chronosphereMonitor `yaml:"spec"`
}

func NewChronosphereMonitorYAML() ChronosphereMonitorYAML {
	return ChronosphereMonitorYAML{
		Api_version: "v1/config",
		Kind:        "Monitor",
	}
}

type chronosphereRecordingRule struct {
	Slug          string                  `yaml:"slug"`
	Name          string                  `yaml:"name"`
	Collection    string                  `yaml:"bucket_slug"`
	Interval_secs int                     `yaml:"interval_secs"`
	Metric_name   string                  `yaml:"metric_name"`
	Expr          string                  `yaml:"prometheus_expr"`
	Label_policy  chronosphereLabelPolicy `yaml:"label_policy"`
}

type chronosphereOperation int

const (
	GEQ chronosphereOperation = iota
	GT
	LEQ
	LT
	EQ
	NEQ
	EXISTS
	NOT_EXISTS
)

func (c chronosphereOperation) String() string {
	return [...]string{"GEQ", "GT", "LEQ", "LT", "EQ", "NEQ", "EXISTS", "NOT_EXISTS"}[c]
}

type chronosphereMonitorConditions struct {
	Value                float64 `yaml:"value,omitempty"`
	Sustain_secs         int     `yaml:"sustain_secs"`
	Resolve_sustain_secs int     `yaml:"resolve_sustain_secs"`
	Op                   string  `yaml:"op"`
}

type chronosphereMonitorSeverity int

const (
	Warn chronosphereMonitorSeverity = iota
	Critical
)

func (c chronosphereMonitorSeverity) String() string {
	return [...]string{"warn", "critical"}[c]
}

type chronosphereMonitor struct {
	Slug                     string                                                           `yaml:"slug"`
	Name                     string                                                           `yaml:"name"`
	Query                    string                                                           `yaml:"prometheus_query"`
	Collection               string                                                           `yaml:"collection_slug"`
	Interval_secs            int                                                              `yaml:"interval_secs"`
	Labels                   map[string]string                                                `yaml:"labels"`
	Notification_policy_slug string                                                           `yaml:"notification_policy_slug"`
	Series_conditions        map[string]map[string]map[string][]chronosphereMonitorConditions `yaml:"series_conditions"`
}
